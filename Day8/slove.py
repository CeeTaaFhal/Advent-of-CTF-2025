import math

p = 105891552782768273485439811488443354235545023673195353053856843893816480862271
g = 2

leaks = [
    74834831693148489075053741970537349864361072646438063822128523522624111096404,
    94637262384206414487913618520407895315549149001067603290715492338419957063638,
    26119415647812686814124878968032828750956202141747974248626227495752618826310,
    4679774184271053791528196045893972569586759227111353536533198888487507918565,
    18247264710550364407701539407739806326963229364366084285259750379893601861765,
    57915316904508068959154652733100932636576891111709785240327600448742235657223,
    48726379408397107751482798948037834170753506073391626907440435722452593080790,
    23985113650578780235980433910057970681859494895610853985857472866552793069375,
    79231016211481853602891211467430186947199626871048819648312025046281485147965,
    1741002057862179063516105232753064091765321308410446556962767548042727938590,
    45723548930603031191234669145592632467258468694483505689072179691228438466667,
    58359671511194341930052508512801343119287048085288142869480583778613556216586,
    36424897628935082604512568766716569943269039796337573854278402880102811617963,
    74124749341279711257845847090110538409556405630352757105373182076739304300759,
    66309699088883552645305984224828051437638962884903042514430099711503266344026,
    3162806651485565481013375199103880408462676315825209573632289159416883750178,
    38582718538740737041784799604514668813686704870272183643601445048856770639975,
    60816150467494956825800367310063997854145812297158134406617773585762215516843,
    12353526085228982771214476339845069964525380861405349768474892062968628975241,
    105582281937486445268146775233874434792742700624750876452894760571703935174919,
    13238662997179930853908762356537888264584682314391321882412877512234731316348,
    75875040959123636492014257513993145046661183624855640826292741601485403285328,
    12149947150174642792165286320748309835337741992502616190760701133669565860666,
    38650263185329843052214216132708910216830022007692554045491912295950867554552,
    92561547647296020081423003558701351791204280991353765906671600253604516771598,
    41349557324733447344437570514434312589869408427300508224464407246422794992797,
    86385180739170312287865404316483035605934760491085055759657242983443484861082,
    39348401982172687025128116440936094277482944374061555213943911942008513049037,
    58273481812023054183980778217247474508696785731672888895966172242039774561634,
    69932445711823749013619544296257448424270930795659726110506648765574551496961,
    11196151841801624492550269516119227591456953234837751240484968196644961160377,
    26041577455573938646072969268840197244828691423833869416465901173451675328995
]

n = len(leaks)

print("="*70)
print("FLAG RECOVERY - CORRECT VERSION")
print("="*70)
print(f"Number of leaks: {n}")

# CORRECT FORMULA: 256*x_i - x_(i+1) = b_i * (256^n - 1)
# Therefore: h_i^256 / h_(i+1) = g^(b_i * (256^n - 1))

factor = 256**n - 1  # THIS IS THE CORRECT FACTOR!
print(f"Factor = 256^{n} - 1")
print(f"Factor value: {factor}")

gcd = math.gcd(factor, p - 1)
print(f"GCD(factor, p-1) = {gcd}")

if gcd > 1:
    print(f"Warning: GCD = {gcd}, this may complicate the discrete log")

print(f"\nStarting byte recovery...\n")

flag_bytes = []

for i in range(n):
    h_i = leaks[i]
    h_i_next = leaks[(i + 1) % n]
    
    # We need: h_i^256 / h_(i+1) = g^(b_i * factor)
    # Compute the target
    target = (pow(h_i, 256, p) * pow(h_i_next, p - 2, p)) % p
    
    # Brute force search for the byte value
    found = False
    for b in range(256):
        # Compute g^(b * factor) mod p
        test = pow(g, (b * factor) % (p - 1), p)
        
        if test == target:
            flag_bytes.append(b)
            found = True
            char_display = chr(b) if 32 <= b < 127 else f"\\x{b:02x}"
            print(f"Byte {i:2d}: {b:3d} ('{char_display}')")
            break
    
    if not found:
        print(f"Byte {i:2d}: NOT FOUND!")
        flag_bytes.append(0)

print("\n" + "="*70)
print("RECOVERED FLAG")
print("="*70)

flag = bytes(flag_bytes)
print(f"Hex: {flag.hex()}")
print(f"Bytes: {flag}")

try:
    flag_str = flag.decode('ascii')
    print(f"\nðŸš© FLAG: {flag_str}")
except:
    print(f"ASCII (with errors): {flag.decode('ascii', errors='replace')}")
